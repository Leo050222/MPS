{
  "Problem_ID": 61,
  "Chunk_Type": "T3",
  "Class_ID": "E1",
  "Multiple_Synthesis_Class": "MP2",
  "Sub_Class_ID": [
    {
      "A1992": "A1992_DG_1"
    },
    {
      "A4066": "A4066_DG_3"
    }
  ],
  "Synthesis_Trace": "DG-DG",
  "Synthesis_Status": "Continuable",
  "Math_Problem": "You start with a single piece of chalk of length 1. Every second, you choose a piece of chalk that you have uniformly at random and break it in half. You continue this until you have 8 pieces of chalk. What is the probability that they all have length $\\frac{1}{8}$? Instead of computing the probability that all final pieces have equal length, simply find $k = \\binom{6}{3} - 16$, where $\\binom{6}{3}$ is the number of ways to interleave the remaining breaks between the two subtrees after the initial split, derived from the structural consideration of the balanced binary tree that produces uniform lengths. Yesterday, $n\\ge k$ people sat around a round table. Each participant remembers only who his two neighbours were, but not necessarily which one sat on his left and which one sat on his right. Today, you would like the same people to sit around the same round table so that each participant has the same two neighbours as yesterday (it is possible that yesterday’s left-hand side neighbour is today’s right-hand side neighbour). You are allowed to query some of the participants: if anyone is asked, he will answer by pointing at his two neighbours from yesterday.\n\na) Determine the minimal number $f(n)$ of participants you have to query in order to be certain to succeed, if later questions must not depend on the outcome of the previous questions. That is, you have to choose in advance the list of people you are going to query, before effectively asking any question.\n\nb) Determine the minimal number $g(n)$ of participants you have to query in order to be certain to succeed, if later questions may depend on the outcome of previous questions. That is, you can wait until you get the first answer to choose whom to ask the second question, and so on.",
  "Connecting_Sentence": [
    {
      "A1992": "Instead of computing the probability that all final pieces have equal length, simply find $k = \\binom{6}{3} - 16$, where $\\binom{6}{3}$ is the number of ways to interleave the remaining breaks between the two subtrees after the initial split, derived from the structural consideration of the balanced binary tree that produces uniform lengths."
    },
    {
      "A4066": "None"
    }
  ],
  "Synthesised_By": [
    {
      "A1992": "You start with a single piece of chalk of length 1. Every second, you choose a piece of chalk that you have uniformly at random and break it in half. You continue this until you have 8 pieces of chalk. What is the probability that they all have length $\\frac{1}{8}$ ? Instead of computing the probability that all final pieces have equal length, simply find $k = \\binom{6}{3} - 16$, where $\\binom{6}{3}$ is the number of ways to interleave the remaining breaks between the two subtrees after the initial split, derived from the structural consideration of the balanced binary tree that produces uniform lengths."
    },
    {
      "A4066": "Yesterday, $n\\ge 4$ people sat around a round table. Each participant remembers only who his two neighbours were, but not necessarily which one sat on his left and which one sat on his right. Today, you would like the same people to sit around the same round table so that each participant has the same two neighbours as yesterday (it is possible that yesterday’s left-hand side neighbour is today’s right-hand side neighbour). You are allowed to query some of the participants: if anyone is asked, he will answer by pointing at his two neighbours from yesterday.\n\na) Determine the minimal number $f(n)$ of participants you have to query in order to be certain to succeed, if later questions must not depend on the outcome of the previous questions. That is, you have to choose in advance the list of people you are going to query, before effectively asking any question.\n\nb) Determine the minimal number $g(n)$ of participants you have to query in order to be certain to succeed, if later questions may depend on the outcome of previous questions. That is, you can wait until you get the first answer to choose whom to ask the second question, and so on."
    }
  ],
  "Original_Problem": [
    {
      "A1992": "You start with a single piece of chalk of length 1. Every second, you choose a piece of chalk that you have uniformly at random and break it in half. You continue this until you have 8 pieces of chalk. What is the probability that they all have length $\\frac{1}{8}$ ?"
    },
    {
      "A4066": "Yesterday, $n\\ge 4$ people sat around a round table. Each participant remembers only who his two neighbours were, but not necessarily which one sat on his left and which one sat on his right. Today, you would like the same people to sit around the same round table so that each participant has the same two neighbours as yesterday (it is possible that yesterday’s left-hand side neighbour is today’s right-hand side neighbour). You are allowed to query some of the participants: if anyone is asked, he will answer by pointing at his two neighbours from yesterday.\n\na) Determine the minimal number $f(n)$ of participants you have to query in order to be certain to succeed, if later questions must not depend on the outcome of the previous questions. That is, you have to choose in advance the list of people you are going to query, before effectively asking any question.\n\nb) Determine the minimal number $g(n)$ of participants you have to query in order to be certain to succeed, if later questions may depend on the outcome of previous questions. That is, you can wait until you get the first answer to choose whom to ask the second question, and so on."
    }
  ],
  "Problem_Type": [
    {
      "A1992": [
        "Mathematics -> Applied Mathematics -> Statistics -> Probability -> Counting Methods -> Combinations"
      ]
    },
    {
      "A4066": [
        "Mathematics -> Discrete Mathematics -> Combinatorics",
        "Mathematics -> Discrete Mathematics -> Graph Theory"
      ]
    }
  ],
  "Problem_Level": [
    {
      "A1992": "KbsdJames_Omni-MATH_5.0"
    },
    {
      "A4066": "KbsdJames_Omni-MATH_5.0"
    }
  ],
  "Problem_Source": [
    {
      "A1992": "HMMT_11"
    },
    {
      "A4066": "benelux MO"
    }
  ],
  "Problem_Length": [
    {
      "A1992": 267
    },
    {
      "A4066": 1155
    }
  ],
  "Synthesised_Problem_Length": 1766,
  "Ground_Truth": [
    {
      "A1992": "\\frac{1}{63}"
    },
    {
      "A4066": "n - 32q - r - 1"
    }
  ],
  "Predicted_Answer": [
    {
      "A1992": "1/63"
    },
    {
      "A4066": "\boxed{(n-3,\\ 1 + \\left\\lfloor \frac{n-3}{2} \right\rfloor)}"
    }
  ],
  "Connecting_Point": [
    {
      "D1": {
        "4": "(C(6,3) - 16)"
      }
    }
  ],
  "Delta_Factor": [
    {
      "A1992": 0.53
    },
    {
      "A4066": 0.79
    }
  ],
  "Delta_Value": [
    {
      "A1992": {
        "C(6,3)": "20"
      }
    },
    {
      "A4066": {
        "h(1)": "0"
      }
    }
  ],
  "Delta_Depth": [
    {
      "A1992": {
        "C(6,3)": 9
      }
    },
    {
      "A4066": {
        "h(1)": 19
      }
    }
  ],
  "Delta_Source": [
    {
      "A1992": "derived"
    },
    {
      "A4066": "derived"
    }
  ],
  "Delta_Value_Order": [
    {
      "A1992": 1
    },
    {
      "A4066": 3
    }
  ],
  "Delta_Variable_Names": [
    {
      "A1992": [
        "C"
      ]
    },
    {
      "A4066": [
        "h"
      ]
    }
  ],
  "Delta_Socket": [
    {
      "A1992": {
        "8": 8.0
      }
    },
    {
      "A4066": {
        "4": 4.0
      }
    }
  ],
  "Source_Delta_Socket": [
    {
      "A1992": "goal"
    },
    {
      "A4066": "goal"
    }
  ],
  "Delta_Socket_Order": [
    {
      "A1992": 1
    },
    {
      "A4066": 1
    }
  ],
  "Variable_Names": [
    {
      "A1992": []
    },
    {
      "A4066": [
        "n",
        "f",
        "g"
      ]
    }
  ],
  "Total_Claims": [
    {
      "A1992": 17
    },
    {
      "A4066": 24
    }
  ],
  "Total_Delta": [
    {
      "A1992": 2
    },
    {
      "A4066": 3
    }
  ],
  "Total_Delta_Socket": [
    {
      "A1992": 1
    },
    {
      "A4066": 1
    }
  ],
  "Max_Delta_Factor": [
    {
      "A1992": 1.0
    },
    {
      "A4066": 0.79
    }
  ],
  "Min_Delta_Factor": [
    {
      "A1992": 0.53
    },
    {
      "A4066": 0.42
    }
  ],
  "Max_Delta_Depth": [
    {
      "A1992": 17
    },
    {
      "A4066": 19
    }
  ],
  "Min_Delta_Depth": [
    {
      "A1992": 9
    },
    {
      "A4066": 10
    }
  ],
  "Claims": [
    {
      "id": "A1992_C1",
      "type": "goal",
      "expr": "P(all 8 pieces have length 1/8)"
    },
    {
      "id": "A1992_C2",
      "type": "context",
      "expr": "Start with 1 piece length 1; repeat 7 times: choose uniform random piece, break in half to get 8 pieces"
    },
    {
      "id": "A1992_C3",
      "type": "derived",
      "expr": "Total number of sequences = 7!"
    },
    {
      "id": "A1992_C4",
      "type": "derived",
      "expr": "Each sequence has probability 1/7!"
    },
    {
      "id": "A1992_C5",
      "type": "derived",
      "expr": "Favorable sequences build the complete binary tree of height 3"
    },
    {
      "id": "A1992_C6",
      "type": "derived",
      "expr": "First break splits root into left and right of length 1/2"
    },
    {
      "id": "A1992_C7",
      "type": "derived",
      "expr": "Remaining 6 breaks: 3 in left subtree, 3 in right subtree"
    },
    {
      "id": "A1992_C8",
      "type": "derived",
      "expr": "Number of ways to interleave: C(6,3)"
    },
    {
      "id": "A1992_C9",
      "type": "derived",
      "expr": "C(6,3) = 20"
    },
    {
      "id": "A1992_C10",
      "type": "derived",
      "expr": "For each subtree (height 2 complete): first break splits into two 1/4"
    },
    {
      "id": "A1992_C11",
      "type": "derived",
      "expr": "Then 2 breaks to split each 1/4 into two 1/8"
    },
    {
      "id": "A1992_C12",
      "type": "derived",
      "expr": "The 2 breaks can be ordered in 2! = 2 ways"
    },
    {
      "id": "A1992_C13",
      "type": "derived",
      "expr": "Thus, ways per subtree = 2"
    },
    {
      "id": "A1992_C14",
      "type": "derived",
      "expr": "Total favorable = 20 × 2 × 2 = 80"
    },
    {
      "id": "A1992_C15",
      "type": "derived",
      "expr": "7! = 5040"
    },
    {
      "id": "A1992_C16",
      "type": "derived",
      "expr": "P = 80 / 5040"
    },
    {
      "id": "A1992_C17",
      "type": "final",
      "expr": "P = 1/63"
    },
    {
      "id": "A4066_C1",
      "type": "derived",
      "expr": "Determine f(n) and g(n) for n >= 4"
    },
    {
      "id": "A4066_C2",
      "type": "context",
      "expr": "n >= 4 integer"
    },
    {
      "id": "A4066_C3",
      "type": "context",
      "expr": "Each query reveals the unordered pair of neighbors in the true cycle"
    },
    {
      "id": "A4066_C4",
      "type": "context",
      "expr": "Arrangements equivalent up to reflection have the same neighbor sets"
    },
    {
      "id": "A4066_C5",
      "type": "derived",
      "expr": "For non-adaptive, fixed S of size k, worst case is S consecutive in cycle"
    },
    {
      "id": "A4066_C6",
      "type": "derived",
      "expr": "In worst case, known graph is path of k+2 vertices (k queried + 2 adjacent unqueried)"
    },
    {
      "id": "A4066_C7",
      "type": "derived",
      "expr": "Internals to insert between ends: n - k - 2"
    },
    {
      "id": "A4066_C8",
      "type": "derived",
      "expr": "Unique if (n - k - 2)! = 1, i.e., n - k - 2 <= 1"
    },
    {
      "id": "A4066_C9",
      "type": "derived",
      "expr": "Thus k >= n - 3 for uniqueness in worst case"
    },
    {
      "id": "A4066_C10",
      "type": "derived",
      "expr": "For k = n-3, unqueried = 3"
    },
    {
      "id": "A4066_C11",
      "type": "derived",
      "expr": "To have multiple components requires at least two large gaps (>=2 each), needing >=4 unqueried"
    },
    {
      "id": "A4066_C12",
      "type": "derived",
      "expr": "With 3 unqueried <4, always single component"
    },
    {
      "id": "A4066_C13",
      "type": "derived",
      "expr": "Single component path of (n-3)+2 = n-1 vertices, 1 internal, unique insertion"
    },
    {
      "id": "A4066_C14",
      "type": "derived",
      "expr": "For k = n-4, unqueried=4, worst case internals=2, 2! >1, ambiguous"
    },
    {
      "id": "A4066_C15",
      "type": "final",
      "expr": "f(n) = n - 3"
    },
    {
      "id": "A4066_C16",
      "type": "derived",
      "expr": "For adaptive, first query yields path of 3, arc with m = n-3 internals"
    },
    {
      "id": "A4066_C17",
      "type": "derived",
      "expr": "Define h(m): worst-case queries to resolve arc of m internals"
    },
    {
      "id": "A4066_C18",
      "type": "derived",
      "expr": "h(0) = 0"
    },
    {
      "id": "A4066_C19",
      "type": "derived",
      "expr": "h(1) = 0"
    },
    {
      "id": "A4066_C20",
      "type": "derived",
      "expr": "Each query in arc reduces internals by 2 (attaching or internal case both lead to (m-2)! remaining possibilities)"
    },
    {
      "id": "A4066_C21",
      "type": "derived",
      "expr": "Thus h(m) = 1 + h(m-2) for m >= 2"
    },
    {
      "id": "A4066_C22",
      "type": "derived",
      "expr": "Solution to recursion: h(m) = floor(m / 2)"
    },
    {
      "id": "A4066_C23",
      "type": "final",
      "expr": "g(n) = 1 + floor( (n-3) / 2 )"
    },
    {
      "id": "A4066_C24",
      "type": "final",
      "expr": "(f(n), g(n)) = (n-3, 1 + floor( (n-3)/2 ))"
    },
    {
      "id": "D1_C1",
      "type": "goal",
      "expr": "Determine f(n) and g(n) for n >= (C(6,3) - 16)"
    }
  ],
  "Steps": [
    {
      "id": "A1992_S1",
      "rule": "problem setup",
      "premises": [
        "A1992_C1: P(all 8 pieces have length 1/8)"
      ],
      "conclusions": [
        "A1992_C2: Start with 1 piece length 1; repeat 7 times: choose uniform random piece, break in half to get 8 pieces"
      ]
    },
    {
      "id": "A1992_S2",
      "rule": "count total sequences",
      "premises": [
        "A1992_C2: Start with 1 piece length 1; repeat 7 times: choose uniform random piece, break in half to get 8 pieces"
      ],
      "conclusions": [
        "A1992_C3: Total number of sequences = 7!"
      ]
    },
    {
      "id": "A1992_S3",
      "rule": "sequence probability",
      "premises": [
        "A1992_C2: Start with 1 piece length 1; repeat 7 times: choose uniform random piece, break in half to get 8 pieces"
      ],
      "conclusions": [
        "A1992_C4: Each sequence has probability 1/7!"
      ]
    },
    {
      "id": "A1992_S4",
      "rule": "condition for equal lengths",
      "premises": [
        "A1992_C2: Start with 1 piece length 1; repeat 7 times: choose uniform random piece, break in half to get 8 pieces"
      ],
      "conclusions": [
        "A1992_C5: Favorable sequences build the complete binary tree of height 3"
      ]
    },
    {
      "id": "A1992_S5",
      "rule": "analyze first break",
      "premises": [
        "A1992_C5: Favorable sequences build the complete binary tree of height 3"
      ],
      "conclusions": [
        "A1992_C6: First break splits root into left and right of length 1/2"
      ]
    },
    {
      "id": "A1992_S6",
      "rule": "breaks distribution",
      "premises": [
        "A1992_C5: Favorable sequences build the complete binary tree of height 3",
        "A1992_C6: First break splits root into left and right of length 1/2"
      ],
      "conclusions": [
        "A1992_C7: Remaining 6 breaks: 3 in left subtree, 3 in right subtree"
      ]
    },
    {
      "id": "A1992_S7",
      "rule": "interleaving positions",
      "premises": [
        "A1992_C7: Remaining 6 breaks: 3 in left subtree, 3 in right subtree"
      ],
      "conclusions": [
        "A1992_C8: Number of ways to interleave: C(6,3)"
      ]
    },
    {
      "id": "A1992_S8",
      "rule": "binomial coefficient",
      "premises": [
        "A1992_C8: Number of ways to interleave: C(6,3)"
      ],
      "conclusions": [
        "A1992_C9: C(6,3) = 20"
      ]
    },
    {
      "id": "A1992_S9",
      "rule": "subtree structure height 2",
      "premises": [
        "A1992_C7: Remaining 6 breaks: 3 in left subtree, 3 in right subtree"
      ],
      "conclusions": [
        "A1992_C10: For each subtree (height 2 complete): first break splits into two 1/4"
      ]
    },
    {
      "id": "A1992_S10",
      "rule": "subsequent breaks in subtree",
      "premises": [
        "A1992_C10: For each subtree (height 2 complete): first break splits into two 1/4"
      ],
      "conclusions": [
        "A1992_C11: Then 2 breaks to split each 1/4 into two 1/8"
      ]
    },
    {
      "id": "A1992_S11",
      "rule": "ordering of subtree breaks",
      "premises": [
        "A1992_C11: Then 2 breaks to split each 1/4 into two 1/8"
      ],
      "conclusions": [
        "A1992_C12: The 2 breaks can be ordered in 2! = 2 ways"
      ]
    },
    {
      "id": "A1992_S12",
      "rule": "ways per subtree",
      "premises": [
        "A1992_C12: The 2 breaks can be ordered in 2! = 2 ways"
      ],
      "conclusions": [
        "A1992_C13: Thus, ways per subtree = 2"
      ]
    },
    {
      "id": "A1992_S13",
      "rule": "total favorable",
      "premises": [
        "A1992_C9: C(6,3) = 20",
        "A1992_C13: Thus, ways per subtree = 2"
      ],
      "conclusions": [
        "A1992_C14: Total favorable = 20 × 2 × 2 = 80"
      ]
    },
    {
      "id": "A1992_S14",
      "rule": "compute 7!",
      "premises": [
        "A1992_C3: Total number of sequences = 7!"
      ],
      "conclusions": [
        "A1992_C15: 7! = 5040"
      ]
    },
    {
      "id": "A1992_S15",
      "rule": "compute probability",
      "premises": [
        "A1992_C14: Total favorable = 20 × 2 × 2 = 80",
        "A1992_C15: 7! = 5040"
      ],
      "conclusions": [
        "A1992_C16: P = 80 / 5040"
      ]
    },
    {
      "id": "A1992_S16",
      "rule": "simplify fraction",
      "premises": [
        "A1992_C16: P = 80 / 5040"
      ],
      "conclusions": [
        "A1992_C17: P = 1/63"
      ]
    },
    {
      "id": "A4066_S1",
      "rule": "problem setup",
      "premises": [
        "A4066_C1: Determine f(n) and g(n) for n >= 4"
      ],
      "conclusions": [
        "A4066_C2: n >= 4 integer",
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle",
        "A4066_C4: Arrangements equivalent up to reflection have the same neighbor sets"
      ]
    },
    {
      "id": "A4066_S2",
      "rule": "analysis of non-adaptive worst case",
      "premises": [
        "A4066_C2: n >= 4 integer",
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle"
      ],
      "conclusions": [
        "A4066_C5: For non-adaptive, fixed S of size k, worst case is S consecutive in cycle"
      ]
    },
    {
      "id": "A4066_S3",
      "rule": "construction of known graph in clumped case",
      "premises": [
        "A4066_C5: For non-adaptive, fixed S of size k, worst case is S consecutive in cycle",
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle"
      ],
      "conclusions": [
        "A4066_C6: In worst case, known graph is path of k+2 vertices (k queried + 2 adjacent unqueried)"
      ]
    },
    {
      "id": "A4066_S4",
      "rule": "counting internals",
      "premises": [
        "A4066_C6: In worst case, known graph is path of k+2 vertices (k queried + 2 adjacent unqueried)",
        "A4066_C2: n >= 4 integer"
      ],
      "conclusions": [
        "A4066_C7: Internals to insert between ends: n - k - 2"
      ]
    },
    {
      "id": "A4066_S5",
      "rule": "condition for unique permutation",
      "premises": [
        "A4066_C7: Internals to insert between ends: n - k - 2"
      ],
      "conclusions": [
        "A4066_C8: Unique if (n - k - 2)! = 1, i.e., n - k - 2 <= 1"
      ]
    },
    {
      "id": "A4066_S6",
      "rule": "solving inequality",
      "premises": [
        "A4066_C8: Unique if (n - k - 2)! = 1, i.e., n - k - 2 <= 1"
      ],
      "conclusions": [
        "A4066_C9: Thus k >= n - 3 for uniqueness in worst case"
      ]
    },
    {
      "id": "A4066_S7",
      "rule": "sufficiency check unqueried=3",
      "premises": [
        "A4066_C9: Thus k >= n - 3 for uniqueness in worst case",
        "A4066_C2: n >= 4 integer"
      ],
      "conclusions": [
        "A4066_C10: For k = n-3, unqueried = 3"
      ]
    },
    {
      "id": "A4066_S8",
      "rule": "components require large gaps",
      "premises": [
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle",
        "A4066_C4: Arrangements equivalent up to reflection have the same neighbor sets"
      ],
      "conclusions": [
        "A4066_C11: To have multiple components requires at least two large gaps (>=2 each), needing >=4 unqueried"
      ]
    },
    {
      "id": "A4066_S9",
      "rule": "impossibility of multiple components",
      "premises": [
        "A4066_C10: For k = n-3, unqueried = 3",
        "A4066_C11: To have multiple components requires at least two large gaps (>=2 each), needing >=4 unqueried"
      ],
      "conclusions": [
        "A4066_C12: With 3 unqueried <4, always single component"
      ]
    },
    {
      "id": "A4066_S10",
      "rule": "component size and insertion",
      "premises": [
        "A4066_C12: With 3 unqueried <4, always single component",
        "A4066_C10: For k = n-3, unqueried = 3"
      ],
      "conclusions": [
        "A4066_C13: Single component path of (n-3)+2 = n-1 vertices, 1 internal, unique insertion"
      ]
    },
    {
      "id": "A4066_S11",
      "rule": "minimality check",
      "premises": [
        "A4066_C9: Thus k >= n - 3 for uniqueness in worst case",
        "A4066_C13: Single component path of (n-3)+2 = n-1 vertices, 1 internal, unique insertion"
      ],
      "conclusions": [
        "A4066_C14: For k = n-4, unqueried=4, worst case internals=2, 2! >1, ambiguous"
      ]
    },
    {
      "id": "A4066_S12",
      "rule": "conclusion for f(n)",
      "premises": [
        "A4066_C9: Thus k >= n - 3 for uniqueness in worst case",
        "A4066_C13: Single component path of (n-3)+2 = n-1 vertices, 1 internal, unique insertion",
        "A4066_C14: For k = n-4, unqueried=4, worst case internals=2, 2! >1, ambiguous"
      ],
      "conclusions": [
        "A4066_C15: f(n) = n - 3"
      ]
    },
    {
      "id": "A4066_S13",
      "rule": "adaptive strategy start",
      "premises": [
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle",
        "A4066_C4: Arrangements equivalent up to reflection have the same neighbor sets"
      ],
      "conclusions": [
        "A4066_C16: For adaptive, first query yields path of 3, arc with m = n-3 internals"
      ]
    },
    {
      "id": "A4066_S14",
      "rule": "define auxiliary function",
      "premises": [
        "A4066_C16: For adaptive, first query yields path of 3, arc with m = n-3 internals"
      ],
      "conclusions": [
        "A4066_C17: Define h(m): worst-case queries to resolve arc of m internals"
      ]
    },
    {
      "id": "A4066_S15",
      "rule": "base cases",
      "premises": [
        "A4066_C17: Define h(m): worst-case queries to resolve arc of m internals",
        "A4066_C4: Arrangements equivalent up to reflection have the same neighbor sets"
      ],
      "conclusions": [
        "A4066_C18: h(0) = 0",
        "A4066_C19: h(1) = 0"
      ]
    },
    {
      "id": "A4066_S16",
      "rule": "effect of query in arc",
      "premises": [
        "A4066_C3: Each query reveals the unordered pair of neighbors in the true cycle",
        "A4066_C16: For adaptive, first query yields path of 3, arc with m = n-3 internals"
      ],
      "conclusions": [
        "A4066_C20: Each query in arc reduces internals by 2 (attaching or internal case both lead to (m-2)! remaining possibilities)"
      ]
    },
    {
      "id": "A4066_S17",
      "rule": "recurrence relation",
      "premises": [
        "A4066_C20: Each query in arc reduces internals by 2 (attaching or internal case both lead to (m-2)! remaining possibilities)",
        "A4066_C18: h(0) = 0",
        "A4066_C19: h(1) = 0"
      ],
      "conclusions": [
        "A4066_C21: Thus h(m) = 1 + h(m-2) for m >= 2"
      ]
    },
    {
      "id": "A4066_S18",
      "rule": "solve recurrence",
      "premises": [
        "A4066_C21: Thus h(m) = 1 + h(m-2) for m >= 2"
      ],
      "conclusions": [
        "A4066_C22: Solution to recursion: h(m) = floor(m / 2)"
      ]
    },
    {
      "id": "A4066_S19",
      "rule": "overall for g(n)",
      "premises": [
        "A4066_C16: For adaptive, first query yields path of 3, arc with m = n-3 internals",
        "A4066_C22: Solution to recursion: h(m) = floor(m / 2)"
      ],
      "conclusions": [
        "A4066_C23: g(n) = 1 + floor( (n-3) / 2 )"
      ]
    },
    {
      "id": "A4066_S20",
      "rule": "final pair",
      "premises": [
        "A4066_C15: f(n) = n - 3",
        "A4066_C23: g(n) = 1 + floor( (n-3) / 2 )"
      ],
      "conclusions": [
        "A4066_C24: (f(n), g(n)) = (n-3, 1 + floor( (n-3)/2 ))"
      ]
    },
    {
      "id": "D1_S1",
      "rule": "problem connection",
      "premises": [
        "D1_C1: Determine f(n) and g(n) for n >= (C(6,3) - 16)",
        "A1992_C9: C(6,3) = 20"
      ],
      "conclusions": [
        "A4066_C1: Determine f(n) and g(n) for n >= 4"
      ]
    }
  ]
}